#!/usr/bin/env ruby
#
# @version 1.1.3
# @author Franklin P. Strube <franklin.strube@gmail.com>
# @copyright 2014 Franklin P. Strube
#
#: Usage: frak <command> [option=value option=value ...]
#:
#: Commands
#:   init          Initialize the current directory for frak deployment
#:   console       Connect to the remote server via SSH
#:   diff          Show differences between local and remote files
#:   pull          Download the remote file(s)
#:   push          Deploy website via the method specified in the config
#:   backups:list  List any backups found on the server
#:   backups:purge Purge all backups
#:   --help        Display this help message
#:   --version     Display the current version of frak, also checks for upgrades
#:
#: Options
#:   env           load the specified environment into the config
#:   method        currently only supports rsync
#:   command       execute a command on the remote server
#:   path          defaults to current directory
#:   remote_path   override what is read from .frak file
#:   rsync_path    override the rsync-path read from .frak file (if present)
#:   ignore        ignore certain files or folders when deploying
#:
#: Examples
#:
#:   Execute a command on your deployment server:
#:     frak console command="vi index.html"
#:
#:   Compare specific files before deploying:
#:     frak diff path="*.html"
#:
#:   Deploy files but exclude certain paths:
#:     frak ignore="logs uploads"

require 'yaml'
require 'digest'
require 'time'
require 'shellwords'
begin
  require 'highline/import'
rescue LoadError
  puts "\033[31mFrak! You're missing the Highline gem. Run \033[33mgem install highline\033[31m to get it.\033[0m"
  exit
end

##
# The main routine of the program. Typical execution is:
#   1. Parse arguments
#   2. Load configuration
#   3. Execute proper command

def main
  # Process the commandline arguments
  $command, $options = parse_command

  # Check for updates
  auto_update

  begin

    if not $command == "init"
      # Load the config, but commandline options take precedence.
      $options.merge!(config) { |k,a,b| a }

      # Load special production config, but commandline options take precedence.
      if $options[:env]
        if config[$options[:env].to_sym].nil?
          raise %Q:Missing configuration for environment "#{$options[:env]}"!:
        end
        $options.merge!(config[$options[:env].to_sym]) { |k,a,b| a }
      end
    end

    # Convert all keys in options to symbols
    $options = Hash[$options.map { |k, v| [k.to_sym, v] }]

    execute
  rescue Exception => e
    say "#{HighLine::RED}#{e.message}#{HighLine::CLEAR}"
    puts e.backtrace if $options[:debug]
  end
end

##
# Outputs the usage / help information for this executable.

def usage
  File.open __FILE__ do |f|
    f.each_line.grep(/^#:/) do |l|
      say l[2..-1]
    end
  end
end

##
# Outputs the version information for the frak tool.

def version
  File.open __FILE__ do |f|
    f.each_line.grep(/^# @version/) do |l|
      return l[11..-2]
    end
  end
end

##
# Parse command and options

def parse_command
  arguments = ARGV.clone
  options = {backup_path: ".backups", backup_retention: "30 days"}
  command = "push"
  while arguments.length > 0
    if arguments[0] =~ /=/ then
      key, value = arguments[0].split '='
      options[key.to_sym] = value
    else
      command = arguments[0]
    end
    arguments.shift
  end

  return [command, options]
end

##
# Read YAML from .frak configuration file

def config
  if File.exists? frakfile
    Hash[YAML.load_file(frakfile).map { |k, v| [k.to_sym, v] }]
  else
    {}
  end
end

##
# Find a .frak configuration file in the directories
# above.

def frakfile
  frakfile = ".frak"
  while not File.exists? frakfile
    break if File.expand_path(frakfile) == '/.frak'
    frakfile = "../#{frakfile}"
  end

  if not File.exists? frakfile
    raise "Frak! No configuration file found! Please run 'frak init' in your project folder."
  end

  return File.expand_path frakfile
end

##
# Which diff command or utility to use
def diff_command
  if $options[:diff]
    return $options[:diff]
  else
    return "diff -Naur"
  end
end

##
# Determine what is the local_path to be deployed

def rsync_files
  # if path= is defined
  if $options[:path]
    paths = $options[:path].split.map { |p| File.expand_path p }
  else
    paths = [Dir.pwd]
  end

  # expand any wildcards
  paths.map! { |p| Dir.glob(p) }
  paths.flatten!

  # make paths relative to .frak file
  paths.map! { |p| p.sub File.dirname(frakfile), "" }

  return paths
end

##
# Generate a filter for rsync

def rsync_filter
  filter = [".frak*", ".git*", ".svn*", ".tags*", "Capfile", "Gemfile*", "Vagrantfile*"]

  # include filters via commandline
  if $options[:ignore]
    filter = filter + $options[:ignore].split
  end

  filter.map! { |e| "--filter='- #{e}'" }

  if File.exists? "#{File.dirname frakfile}/.frakignore" then
    filter.push "--filter='.e .frakignore'"
  end

  filter.join ' '
end

##
# List any backups found on the server

def backups_list
  system %Q:ssh #{$options[:server]} 'ls #{$options[:remote_path]}/#{$options[:backup_path]}':
end

##
# Purge any outdated backups

def backups_purge
  begin
    date = parse_date "#{$options[:backup_retention]} ago"
  rescue
    raise "Invalid retention date! #{$options[:backup_retention]}"
  end
  say "#{HighLine::YELLOW}Purging old backups before #{date.strftime "%c"}.#{HighLine::CLEAR}"

  system %Q:ssh #{$options[:server]} 'cd #{$options[:remote_path]}; for x in `ls #{$options[:backup_path]}`; do [ $x -lt "#{date.strftime '%Y%m%d%H%M%S'}" ] && rm -rf #{$options[:backup_path]}/$x && echo Backup $x removed; done':
end

##
# Create a patch of the latest backup

def backups_patch
  return unless $backup_path

  hash = Digest::SHA2.new.update(Time.new.strftime("%Y%m%d%H%M%S")).to_s
  patch_command = "" +
    "find . -type f | " +
    "grep -v #{hash}.patch | " +
    "cut -c3- | " +
    "xargs -I {} diff -u -x #{hash}.patch --label a/{} --label b/{} ./{} #{$options[:remote_path]}/{}"
  say "#{HighLine::YELLOW}Generating patch file #{hash}.patch.#{HighLine::CLEAR}"
  system %Q:ssh #{$options[:server]} 'cd #{$options[:remote_path]}/#{$backup_path} 2>/dev/null || exit; #{patch_command} > #{$options[:remote_path]}/#{$backup_path}/#{hash}.patch':
end

##
# Parse a date from a string of the format "x <days|weeks|months|years> [ago]"

def parse_date(string)
  parts = string.split

  if parts[1][0..5] == "second"
    seconds = parts[0].to_f
  elsif parts[1][0..5] == "minute"
    seconds = parts[0].to_f * 60
  elsif parts[1][0..3] == "hour"
    seconds = parts[0].to_f * 60 * 60
  elsif parts[1][0..2] == "day"
    seconds = parts[0].to_f * 60 * 60 * 24
  elsif parts[1][0..3] == "week"
    seconds = parts[0].to_f * 60 * 60 * 24 * 7
  elsif parts[1][0..4] == "month"
    seconds = parts[0].to_f * 60 * 60 * 24 * 30
  elsif parts[1][0..3] == "year"
    seconds = parts[0].to_f * 60 * 60 * 24 * 365
  end

  if parts[2] == "ago"
    return Time.now - seconds
  else
    return Time.now + seconds
  end
end

##
# Generate the entire rsync command. Uses rsync's --files-from
# parameter to deploy multiple paths at once.

def rsync_command(options = nil)
  if rsync_files.join.length > 0
    rsync = "echo \"#{rsync_files.join("\n")}\" | "
  end

  # Flip the source and destination if this is a pull command
  if $command == "pull"
    # trailing slashes are important for pull
    source = "#{$options[:server]}:#{$options[:remote_path]}/"
    destination = "#{File.dirname frakfile}/"
  else
    source = "#{File.dirname frakfile}/"
    destination = "#{$options[:server]}:#{$options[:remote_path]}"
  end

  # Figure out backup options
  if !$options[:backup_path].nil? && $options[:backup_path]
    backup = ["--exclude \"#{$options[:backup_path]}\""]
    if not $command == "pull"
      # keep the same backup path for all rsync_commands
      $backup_path = "#{$options[:backup_path]}/#{Time.new.strftime("%Y%m%d%H%M%S")}" if $backup_path.nil?
      backup.push "--backup --backup-dir \"#{$backup_path}\""
    end
    backup = "#{backup.join ' '} "
  end

  rsync = "#{rsync}rsync " +
    "--archive --no-group --no-owner --no-perms --no-times --human-readable " +
    "--compress --checksum --itemize-changes --recursive --delete " +
    ($options[:rsync_path].nil? ? "" : "--rsync-path=\"#{$options[:rsync_path]}\" ") +
    "#{rsync_filter} " +
    backup +
    "#{options} " +
    (rsync_files.join.length > 0 ? "--files-from=- --relative " : "") +
    "'#{source}' #{destination}"
end

##
# Execute the appropriate command

def execute
  case $command
    when "init"
      system "touch .frak .frakignore && $EDITOR .frak"

    when "backups:list"
      backups_list

    when "backups:purge"
      backups_purge

    when "console"
      system "ssh #{$options[:server]} #{$options[:command]}"

    when "push", "pull"
      # generate a dry-run command
      command = rsync_command "--dry-run"

      if $options[:debug]
        say "#{HighLine::BLUE}#{command}#{HighLine::CLEAR}"
      end

      # run it from the root directory where .frak file is found
      Dir.chdir File.dirname frakfile do
        system command
      end

      begin
        # prompt for continuance
        proceed = agree("#{HighLine::YELLOW}The above actions will be taken. Continue? (This cannot be undone): #{HighLine::CLEAR}")
        if proceed
          command = rsync_command
          # run in the directory that .frak file is found
          Dir.chdir File.dirname frakfile do
            system command
            backups_patch
            backups_purge
            if $options[:after]
              say "#{HighLine::YELLOW}Executing commands on remote server.#{HighLine::CLEAR}"
              system "ssh #{$options[:server]} '#{$options[:after]}'"
            end
          end
          say "#{HighLine::GREEN}Deployment complete.#{HighLine::CLEAR}"
        else
          say "#{HighLine::RED}Deployment cancelled by user.#{HighLine::CLEAR}"
        end
      # rescue handles ctrl+c
      rescue Interrupt
        say "\n#{HighLine::RED}Deployment cancelled by user.#{HighLine::CLEAR}"
      end

    when "diff"
      # show differences between server and local
      changes = ""
      Dir.chdir File.dirname frakfile do
        changes = `#{rsync_command "--dry-run"}`
      end
      num_changes = changes.lines.count

      proceed = num_changes > 10 ? agree("#{HighLine::YELLOW}#{changes.lines.count} file(s) will be compared. Continue?#{HighLine::CLEAR}") : true

      if proceed
        Dir.chdir File.dirname frakfile do
          changes.each_line do |line|
            action, file = line.chomp.split(' ', 2)

            # apply labels to our diff so we know what we're looking at
            remote_label = "#{$options[:server]}/#{file}"
            local_label  = "local/#{file}"
            system %Q:bash -c '#{diff_command} --label #{remote_label} --label #{local_label} <(ssh #{$options[:server]} "cat #{$options[:remote_path]}/#{file} 2>/dev/null") "#{file}"':
          end
        end
      end

    when "--help"
      usage

    when "--version"
      say version

    else
      usage

  end
end

def auto_update
  require 'open-uri'
  open("https://raw.github.com/fstrube/frak/master/bin/frak") do |r|
    r.each_line do |line|
      if line[0..9] == "# @version"
        new_version = line[11..-2].to_s
        if new_version != version
          upgrade = agree("#{HighLine::YELLOW}Version #{new_version} is now available. You are currently running version #{version}. Would you like to upgrade?#{HighLine::CLEAR}")
          if upgrade
            File.open(__FILE__, 'w') do |file|
              r.pos = 0
              file.write(r.read)
            end
            say "Upgraded to version #{new_version}."
            system Shellwords.join([$0] + ARGV) unless $command == "--version"
            exit
          end
        end
      end
    end
  end
end

if __FILE__ == $0
  main
end
